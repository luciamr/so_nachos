Plancha 1 - Introducción a Nachos

1. Cuánta memoria tiene la máquina simulada por Nachos?

MemorySize = NumPhysPages * PageSize
NumPhysPages = 32
PageSize = SectorSize
SectorSize = 128 bytes
Por lo tanto, la memoria de la máquina simulada para Nachos es de 4096 bytes, es decir, 4 kB.
Fuente: machine/machine.h y machine/disk.h

2. Cómo cambiaría ese valor?

Modificando el valor de NumPhysPages.

3. De qué tamaño es un disco?

La clase Disk define un disco físico. El disco tiene una única superficie, dividida en "tracks", y cada "track" está dividido en "sectors". Todos los "tracks" tienen la misma cantidad de "sectors" y todos los "sectors" tienen el mismo número de bytes de almacenamiento.
SectorSize = 128 bytes
SectorsPerTrack = 32
NumTracks = 32
NumSectors = SectorsPerTrack * NumTracks (total)
Luego, un disco tiene un tamaño de 131.072 bytes, es decir, 128 kB.
Fuente: machine/disk.h

4. Cuántas instrucciones del MIPS simula Nachos?

Simula 58 instrucciones.
	{"ADD r%d,r%d,r%d", {RD, RS, RT}},
	{"ADDI r%d,r%d,%d", {RT, RS, EXTRA}},
	{"ADDIU r%d,r%d,%d", {RT, RS, EXTRA}},
	{"ADDU r%d,r%d,r%d", {RD, RS, RT}},
	{"AND r%d,r%d,r%d", {RD, RS, RT}},
	{"ANDI r%d,r%d,%d", {RT, RS, EXTRA}},
	{"BEQ r%d,r%d,%d", {RS, RT, EXTRA}},
	{"BGEZ r%d,%d", {RS, EXTRA, NONE}},
	{"BGEZAL r%d,%d", {RS, EXTRA, NONE}},
	{"BGTZ r%d,%d", {RS, EXTRA, NONE}},
	{"BLEZ r%d,%d", {RS, EXTRA, NONE}},
	{"BLTZ r%d,%d", {RS, EXTRA, NONE}},
	{"BLTZAL r%d,%d", {RS, EXTRA, NONE}},
	{"BNE r%d,r%d,%d", {RS, RT, EXTRA}},
	{"DIV r%d,r%d", {RS, RT, NONE}},
	{"DIVU r%d,r%d", {RS, RT, NONE}},
	{"J %d", {EXTRA, NONE, NONE}},
	{"JAL %d", {EXTRA, NONE, NONE}},
	{"JALR r%d,r%d", {RD, RS, NONE}},
	{"JR r%d,r%d", {RD, RS, NONE}},
	{"LB r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"LBU r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"LH r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"LHU r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"LUI r%d,%d", {RT, EXTRA, NONE}},
	{"LW r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"LWL r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"LWR r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"MFHI r%d", {RD, NONE, NONE}},
	{"MFLO r%d", {RD, NONE, NONE}},
	{"MTHI r%d", {RS, NONE, NONE}},
	{"MTLO r%d", {RS, NONE, NONE}},
	{"MULT r%d,r%d", {RS, RT, NONE}},
	{"MULTU r%d,r%d", {RS, RT, NONE}},
	{"NOR r%d,r%d,r%d", {RD, RS, RT}},
	{"OR r%d,r%d,r%d", {RD, RS, RT}},
	{"ORI r%d,r%d,%d", {RT, RS, EXTRA}},
	{"RFE", {NONE, NONE, NONE}},
	{"SB r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"SH r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"SLL r%d,r%d,%d", {RD, RT, EXTRA}},
	{"SLLV r%d,r%d,r%d", {RD, RT, RS}},
	{"SLT r%d,r%d,r%d", {RD, RS, RT}},
	{"SLTI r%d,r%d,%d", {RT, RS, EXTRA}},
	{"SLTIU r%d,r%d,%d", {RT, RS, EXTRA}},
	{"SLTU r%d,r%d,r%d", {RD, RS, RT}},
	{"SRA r%d,r%d,%d", {RD, RT, EXTRA}},
	{"SRAV r%d,r%d,r%d", {RD, RT, RS}},
	{"SRL r%d,r%d,%d", {RD, RT, EXTRA}},
	{"SRLV r%d,r%d,r%d", {RD, RT, RS}},
	{"SUB r%d,r%d,r%d", {RD, RS, RT}},
	{"SUBU r%d,r%d,r%d", {RD, RS, RT}},
	{"SW r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"SWL r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"SWR r%d,%d(r%d)", {RT, EXTRA, RS}},
	{"XOR r%d,r%d,r%d", {RD, RS, RT}},
	{"XORI r%d,r%d,%d", {RT, RS, EXTRA}},
	{"SYSCALL", {NONE, NONE, NONE}}
Fuente: machine/mipssim.h
	
5. Explicar el código que procesa la instrucción "add".

int sum; //define la variable int sum
sum = registers[(int)instr->rs] + registers[(int)instr->rt]; //almacena en sum la suma de los int que se encuentran en rs y rt
if (!((registers[(int)instr->rs] ^ registers[(int)instr->rt]) & SIGN_BIT) && //verifica 
    ((registers[(int)instr->rs] ^ sum) & SIGN_BIT)) {
    RaiseException(OverflowException, 0);
    return;
}
registers[(int)instr->rd] = sum;

